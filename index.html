const clickableMeshes = {
    "Monitor_Wide_M_Monitor_Wide_Screen_0": { url: "about.html", label: "About Page" },
    "Keyboard_M_Keyboard_0": { url: "contact.html", label: "Contact Page" },
    "1_M_HUION_KAMVAS_GT_221_PRO_0": { url: "works.html", label: "Works Page" }
};

result.meshes.forEach(mesh => {
    if(clickableMeshes[mesh.name]) {
        mesh.actionManager = new BABYLON.ActionManager(scene);

        // Hover: highlight + popup
        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                () => {
                    mesh.originalColor = mesh.material ? mesh.material.diffuseColor.clone() : null;
                    if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(1,1,0);

                    tooltip.style.display = "block";
                    tooltip.textContent = clickableMeshes[mesh.name].label;
                }
            )
        );

        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                () => {
                    if(mesh.material && mesh.originalColor) 
                        mesh.material.diffuseColor = mesh.originalColor;
                    tooltip.style.display = "none";
                }
            )
        );

        // Click: zoom + navigate
        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                () => {
                    const distance = 10;
                    const meshPos = mesh.getBoundingInfo().boundingBox.centerWorld;

                    const direction = camera.position.subtract(meshPos).normalize();
                    const targetPosition = meshPos.add(direction.scale(distance));

                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraZoom",
                        camera,
                        "position",
                        60, 60,
                        camera.position.clone(),
                        targetPosition,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );

                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraTarget",
                        camera,
                        "target",
                        60, 60,
                        camera.getTarget().clone(),
                        meshPos,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );

                    setTimeout(() => {
                        window.location.href = clickableMeshes[mesh.name].url;
                    }, 700);
                }
            )
        );
    }
});

    const canvas = document.getElementById("renderCanvas");
    const tooltip = document.getElementById("tooltip");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = async () => {
        const scene = new BABYLON.Scene(engine);

        // Camera setup
        const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 80, 0), scene);
        camera.rotation = new BABYLON.Vector3(
            0.4026,
            -2.5294 + Math.PI/1.6,
            0
        );
        camera.speed = 500;
        camera.inertia = 0;
        camera.angularSensibility = 500;
        camera.attachControl(canvas, true);

        // Light
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
        light.intensity = 0.9;

        // Load GLB
        const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "", 
            "https://raw.githubusercontent.com/OriAmberLyn/SiteAssets/edd67b281627d2115426c975dc07ccdf4532893c/", 
            "desk_asset%20(1).glb", 
            scene
        );

        // Remove Can_Momster object
        const canMomster = scene.getMeshByName("Can_Momster_M_Can_Momster_0");
        if (canMomster) canMomster.dispose();

        // Remove material from Monitor_Wide
        const monitorWide = scene.getMeshByName("Monitor_Wide_M_Monitor_Wide_Screen_0");
        if (monitorWide) monitorWide.material = null;

        // Scale all meshes
        result.meshes.forEach(mesh => mesh.scaling = new BABYLON.Vector3(1,1,1));

        // Clickable meshes with Google Sites URLs
        const clickableMeshes = {
            "Monitor_Wide_M_Monitor_Wide_Screen_0": "about.html",
            "Keyboard_M_Keyboard_0": "contact.html",
            "1_M_HUION_KAMVAS_GT_221_PRO_0": "works.html"
        };

        // Hover and click interactions
        result.meshes.forEach(mesh => {
            if(clickableMeshes[mesh.name]) {
                mesh.actionManager = new BABYLON.ActionManager(scene);

                // Highlight on hover
                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOverTrigger,
                        function() {
                            mesh.originalColor = mesh.material ? mesh.material.diffuseColor.clone() : null;
                            if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(1,1,0);
                            tooltip.style.display = "block";
                            tooltip.textContent = mesh.name;
                        }
                    )
                );

                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOutTrigger,
                        function() {
                            if(mesh.material && mesh.originalColor) mesh.material.diffuseColor = mesh.originalColor;
                            tooltip.style.display = "none";
                        }
                    )
                );

                // Click: zoom camera then navigate on same tab
                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPickTrigger,
                        function() {
                            const distance = 10;
                            const meshPos = mesh.getBoundingInfo().boundingBox.centerWorld;

                            // Move camera toward mesh
                            const direction = camera.position.subtract(meshPos).normalize();
                            const targetPosition = meshPos.add(direction.scale(distance));

                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraZoom",
                                camera,
                                "position",
                                60,
                                60,
                                camera.position.clone(),
                                targetPosition,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.CubicEase()
                            );

                            // Animate camera target to look at mesh
                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraTarget",
                                camera,
                                "target",
                                60,
                                60,
                                camera.getTarget().clone(),
                                meshPos,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.CubicEase()
                            );

                            // Navigate after animation
                            setTimeout(() => {
                                const url = clickableMeshes[mesh.name];
                                window.location.href = url; // same tab
                            }, 700);
                        }
                    )
                );
            }
        });

        // Tooltip follows mouse
        scene.onPointerMove = function(evt) {
            tooltip.style.left = evt.clientX + 10 + "px";
            tooltip.style.top = evt.clientY + 10 + "px";
        };

        return scene;
    };

    createScene().then(scene => {
        engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
